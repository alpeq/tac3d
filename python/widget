{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "167292df",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Copyright 2023 wngfra.\n",
    "# SPDX-License-Identifier: Apache-2.0\n",
    "\n",
    "import os\n",
    "from typing import Optional\n",
    "\n",
    "import nengo\n",
    "import numpy as np\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "from BarGenerator import BarGenerator\n",
    "from custom_learning_rules import SynapticSampling\n",
    "from nengo_extras.plot_spikes import plot_spikes\n",
    "\n",
    "font = {\"weight\": \"normal\", \"size\": 30}\n",
    "\n",
    "matplotlib.rc(\"font\", **font)\n",
    "\n",
    "\n",
    "def gen_transform(pattern=\"random\", weights=None):\n",
    "    W: Optional[np.ndarray] = None\n",
    "\n",
    "    def inner(shape, weights=weights):\n",
    "        \"\"\"_summary_\n",
    "\n",
    "        Args:\n",
    "            shape (array_like): Linear transform mapping of shape (size_out, size_mid).\n",
    "        Returns:\n",
    "            _type_: _description_\n",
    "        \"\"\"\n",
    "        match pattern:\n",
    "            case \"identity_excitation\":\n",
    "                W = 1\n",
    "            case \"identity_inhibition\":\n",
    "                W = -1\n",
    "            case \"exclusive_excitation\":\n",
    "                assert shape[0] == shape[1], \"Transform matrix is not symmetric!\"\n",
    "                W = np.ones(shape) - np.eye(shape[0])\n",
    "            case \"exclusive_inhibition\":\n",
    "                assert shape[0] == shape[1], \"Transform matrix is not symmetric!\"\n",
    "                W = -np.ones(shape) + 2 * np.eye(shape[0])\n",
    "                W[W < 0] *= 2\n",
    "            case \"custom\":\n",
    "                if weights is None:\n",
    "                    raise ValueError(\"No weights provided!\")\n",
    "                W = weights\n",
    "            case \"zero\":\n",
    "                W = 0\n",
    "            case _:\n",
    "                W = nengo.Dense(\n",
    "                    shape,\n",
    "                    init=nengo.dists.Gaussian(0, 0.5),\n",
    "                )\n",
    "        return W\n",
    "\n",
    "    return inner\n",
    "\n",
    "\n",
    "class Delay:\n",
    "    def __init__(self, dimensions, timesteps=50):\n",
    "        self.history = np.zeros((timesteps, dimensions))\n",
    "\n",
    "    def step(self, t, x):\n",
    "        self.history = np.roll(self.history, -1)\n",
    "        self.history[-1] = x\n",
    "        return self.history[0]\n",
    "\n",
    "\n",
    "# Function to inhibit the error population after 15s\n",
    "def inhib(t):\n",
    "    return 2 if t > duration * 0.6 else 0.0\n",
    "\n",
    "\n",
    "stim_shape = (15, 15)\n",
    "stim_size = np.prod(stim_shape)\n",
    "bar_generator = BarGenerator(stim_shape)\n",
    "\n",
    "# Prepare dataset\n",
    "X_train, y_train = bar_generator.generate_bars(\n",
    "    2000,\n",
    "    min_offset=(5, 5),\n",
    "    max_offset=(11, 11),\n",
    "    min_angle=0,\n",
    "    max_angle=180,\n",
    "    min_dim=(2, 10),\n",
    "    max_dim=(3, 20),\n",
    ")\n",
    "y_train = (y_train - 90) / 180\n",
    "\n",
    "\n",
    "# Simulation parameters\n",
    "dt = 1e-3\n",
    "max_rate = 150  # Hz\n",
    "amp = 1.0\n",
    "rate_target = max_rate * amp  # must be in amplitude scaled units\n",
    "\n",
    "n_hidden_neurons = 64\n",
    "n_latent_variables = 3\n",
    "n_state_neurons = 10\n",
    "presentation_time = 10\n",
    "duration = 10\n",
    "sample_every = 10 * dt\n",
    "\n",
    "learning_rate = 6e-8\n",
    "delay = Delay(1, timesteps=int(0.1 / dt))\n",
    "\n",
    "\n",
    "default_neuron = nengo.AdaptiveLIF(amplitude=amp, tau_rc=0.01)\n",
    "default_rates = nengo.dists.Choice([max_rate])\n",
    "default_intercepts = nengo.dists.Choice([0])\n",
    "\n",
    "layer_confs = [\n",
    "    dict(\n",
    "        name=\"state_node\",\n",
    "        neuron=None,\n",
    "        output=lambda t: y_train[int(t / presentation_time)],\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"state\",\n",
    "        n_neurons=n_state_neurons,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"delay_node\",\n",
    "        neuron=None,\n",
    "        output=delay.step,\n",
    "        size_in=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"delayed_state\",\n",
    "        n_neurons=10,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"delta_state\",\n",
    "        n_neurons=10,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"stimulus\",\n",
    "        neuron=None,\n",
    "        output=lambda t: X_train[int(t / presentation_time)].ravel(),\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"stim\",\n",
    "        neuron=nengo.PoissonSpiking(nengo.LIFRate(amplitude=amp)),\n",
    "        n_neurons=stim_size,\n",
    "        dimensions=3,\n",
    "        on_chip=False,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"hidden\",\n",
    "        n_neurons=n_hidden_neurons,\n",
    "        dimensions=2,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"output\",\n",
    "        n_neurons=stim_size,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"inhibitor\",\n",
    "        n_neurons=1,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"reconstruction_error\",\n",
    "        n_neurons=stim_size,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "]\n",
    "\n",
    "conn_confs = [\n",
    "    # state variable: angle\n",
    "    dict(\n",
    "        pre=\"state_node\",\n",
    "        post=\"state\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"state_node\",\n",
    "        post=\"delay_node\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"delay_node\",\n",
    "        post=\"delayed_state\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"state\",\n",
    "        post=\"delta_state\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"delayed_state\",\n",
    "        post=\"delta_state\",\n",
    "        transform=gen_transform(\"identity_inhibition\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"stimulus\",\n",
    "        post=\"stim_neurons\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"stim_neurons\",\n",
    "        post=\"hidden_neurons\",\n",
    "        #learning_rule=nengo.Oja(learning_rate=learning_rate),\n",
    "        synapse=0.01,\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"hidden_neurons\",\n",
    "        post=\"inhibitor_neurons\",\n",
    "        synapse=0.01,\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"inhibitor_neurons\",\n",
    "        post=\"hidden_neurons\",\n",
    "        transform=gen_transform(\"custom\", weights=-4 * np.ones((n_hidden_neurons, 1))),\n",
    "        synapse=0.01,\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"hidden_neurons\",\n",
    "        post=\"output_neurons\",\n",
    "        transform=gen_transform(),\n",
    "        synapse=0.01,\n",
    "        #learning_rule=nengo.PES(learning_rate=1e-7),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"stim_neurons\",\n",
    "        post=\"reconstruction_error_neurons\",\n",
    "        transform=gen_transform(\"identity_inhibition\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"output_neurons\",\n",
    "        post=\"reconstruction_error_neurons\",\n",
    "    ),\n",
    "]\n",
    "\n",
    "learning_confs = []\n",
    "\n",
    "\n",
    "# Create the Nengo model\n",
    "with nengo.Network(label=\"tacnet\", seed=1) as model:\n",
    "    layers = dict()\n",
    "    connections = dict()\n",
    "    probes = dict()\n",
    "\n",
    "    # Create layers\n",
    "    for k, layer_conf in enumerate(layer_confs):\n",
    "        layer_conf = dict(layer_conf)  # Copy layer configuration\n",
    "        name = layer_conf.pop(\"name\")\n",
    "        n_neurons = layer_conf.pop(\"n_neurons\", 1)\n",
    "        dimensions = layer_conf.pop(\"dimensions\", 1)\n",
    "        encoders = layer_conf.pop(\n",
    "            \"encoders\", nengo.dists.ScatteredHypersphere(surface=True)\n",
    "        )\n",
    "        max_rates = layer_conf.pop(\"max_rates\", default_rates)\n",
    "        radius = layer_conf.pop(\"radius\", 1.0)\n",
    "        neuron_type = layer_conf.pop(\"neuron\", default_neuron)\n",
    "        on_chip = layer_conf.pop(\"on_chip\", False)\n",
    "        block = layer_conf.pop(\"block\", None)\n",
    "        output = layer_conf.pop(\"output\", None)\n",
    "        size_in = layer_conf.pop(\"size_in\", None)\n",
    "\n",
    "        assert len(layer_conf) == 0, \"Unused fields in {}: {}\".format(\n",
    "            [name], list(layer_conf)\n",
    "        )\n",
    "\n",
    "        if neuron_type is None:\n",
    "            assert not on_chip, \"Nodes can only be run off-chip\"\n",
    "\n",
    "            layer = nengo.Node(output=output, size_in=size_in, label=name)\n",
    "            layers[name] = layer\n",
    "            probe = nengo.Probe(\n",
    "                layer, synapse=0.01, sample_every=sample_every, label=\"%s_probe\" % name\n",
    "            )\n",
    "            probes[name] = probe\n",
    "        else:\n",
    "            layer = nengo.Ensemble(\n",
    "                n_neurons,\n",
    "                dimensions=dimensions,\n",
    "                radius=radius,\n",
    "                encoders=encoders,\n",
    "                intercepts=default_intercepts,\n",
    "                neuron_type=neuron_type,\n",
    "                max_rates=max_rates,\n",
    "                normalize_encoders=True,\n",
    "                label=name,\n",
    "            )\n",
    "            layers[name] = layer\n",
    "            layers[name + \"_neurons\"] = layer.neurons\n",
    "\n",
    "            # Add a probe so we can measure individual layer rates\n",
    "            probe = nengo.Probe(\n",
    "                layer, synapse=0.01, sample_every=sample_every, label=\"%s_probe\" % name\n",
    "            )\n",
    "            probes[name] = probe\n",
    "            probe = nengo.Probe(\n",
    "                layer.neurons,\n",
    "                synapse=0.01,\n",
    "                sample_every=sample_every,\n",
    "                label=\"%s_neurons_probe\" % name,\n",
    "            )\n",
    "            probes[name + \"_neurons\"] = probe\n",
    "\n",
    "    for k, conn_conf in enumerate(conn_confs):\n",
    "        conn_conf = dict(conn_conf)  # Copy connection configuration\n",
    "        pre = conn_conf.pop(\"pre\")\n",
    "        post = conn_conf.pop(\"post\")\n",
    "        synapse = conn_conf.pop(\"synapse\", None)\n",
    "        solver = conn_conf.pop(\"solver\", None)\n",
    "        transform = conn_conf.pop(\"transform\", gen_transform())\n",
    "        learning_rule = conn_conf.pop(\"learning_rule\", None)\n",
    "        name = \"{}2{}\".format(pre, post)\n",
    "        function = conn_conf.pop(\"function\", None)\n",
    "\n",
    "        assert len(conn_conf) == 0, \"Unused fields in {}: {}\".format(\n",
    "            [name], list(layer_conf)\n",
    "        )\n",
    "        conn = nengo.Connection(\n",
    "            layers[pre],\n",
    "            layers[post],\n",
    "            function=function,\n",
    "            transform=transform((layers[post].size_in, layers[pre].size_in)),\n",
    "            synapse=synapse,\n",
    "            label=name,\n",
    "        )\n",
    "        if solver:\n",
    "            conn.solver = solver\n",
    "        if learning_rule:\n",
    "            conn.learning_rule_type = learning_rule\n",
    "        connections[name] = conn\n",
    "\n",
    "        probe = nengo.Probe(\n",
    "            conn,\n",
    "            \"weights\",\n",
    "            synapse=0.01,\n",
    "            sample_every=sample_every,\n",
    "            label=\"weights_{}\".format(name),\n",
    "        )\n",
    "        probes[name] = probe\n",
    "\n",
    "    # Connect learning rule\n",
    "    for k, learning_conf in enumerate(learning_confs):\n",
    "        learning_conf = dict(learning_conf)\n",
    "        pre = learning_conf.pop(\"pre\")\n",
    "        post = learning_conf.pop(\"post\")\n",
    "        transform = learning_conf.pop(\"transform\", 1)\n",
    "        nengo.Connection(\n",
    "            layers[pre],\n",
    "            connections[post].learning_rule,\n",
    "            transform=transform,\n",
    "        )\n",
    "\n",
    "\"\"\"Run in non-GUI mode\n",
    "\"\"\"\n",
    "with nengo.Simulator(model, dt=dt, optimize=True) as sim:\n",
    "    sim.run(duration)\n",
    "\n",
    "conn_name = \"{}2{}\".format(\"stim_neurons\", \"hidden_neurons\")\n",
    "ens_names = [\"state\", \"stim_neurons\", \"hidden_neurons\", \"hidden\"]\n",
    "\n",
    "plt.figure(figsize=(5, 10))\n",
    "# Find weight row with max variance\n",
    "neuron = np.argmax(np.mean(np.var(sim.data[probes[conn_name]], axis=0), axis=1))\n",
    "plt.plot(sim.trange(sample_every), sim.data[probes[conn_name]][:, neuron, :])\n",
    "plt.xlabel(\"time (s)\")\n",
    "plt.ylabel(\"weights\")\n",
    "\n",
    "fig, axs = plt.subplots(len(ens_names), 1, figsize=(5 * len(ens_names), 10))\n",
    "for i, ens_name in enumerate(ens_names):\n",
    "    if \"neurons\" in ens_name:\n",
    "        plot_spikes(\n",
    "            sim.trange(sample_every=sample_every), sim.data[probes[ens_name]], ax=axs[i]\n",
    "        )\n",
    "        axs[i].set_ylabel(\"neuron\")\n",
    "    else:\n",
    "        axs[i].plot(sim.trange(sample_every=sample_every), sim.data[probes[ens_name]])\n",
    "        axs[i].set_ylabel(\"encoder\")\n",
    "    axs[i].set_title(ens_name)\n",
    "    axs[i].set_xlabel(\"time (s)\")\n",
    "    axs[i].grid()\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "f74da817",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Copyright 2023 wngfra.\n",
    "# SPDX-License-Identifier: Apache-2.0\n",
    "\n",
    "import os\n",
    "from typing import Optional\n",
    "\n",
    "import nengo\n",
    "import numpy as np\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "from BarGenerator import BarGenerator\n",
    "from custom_learning_rules import SynapticSampling\n",
    "from nengo_extras.plot_spikes import plot_spikes\n",
    "\n",
    "font = {\"weight\": \"normal\", \"size\": 30}\n",
    "\n",
    "matplotlib.rc(\"font\", **font)\n",
    "\n",
    "\n",
    "def gen_transform(pattern=\"random\", weights=None):\n",
    "    W: Optional[np.ndarray] = None\n",
    "\n",
    "    def inner(shape, weights=weights):\n",
    "        \"\"\"_summary_\n",
    "\n",
    "        Args:\n",
    "            shape (array_like): Linear transform mapping of shape (size_out, size_mid).\n",
    "        Returns:\n",
    "            _type_: _description_\n",
    "        \"\"\"\n",
    "        match pattern:\n",
    "            case \"identity_excitation\":\n",
    "                W = 1\n",
    "            case \"identity_inhibition\":\n",
    "                W = -1\n",
    "            case \"exclusive_excitation\":\n",
    "                assert shape[0] == shape[1], \"Transform matrix is not symmetric!\"\n",
    "                W = np.ones(shape) - np.eye(shape[0])\n",
    "            case \"exclusive_inhibition\":\n",
    "                assert shape[0] == shape[1], \"Transform matrix is not symmetric!\"\n",
    "                W = -np.ones(shape) + 2 * np.eye(shape[0])\n",
    "                W[W < 0] *= 2\n",
    "            case \"custom\":\n",
    "                if weights is None:\n",
    "                    raise ValueError(\"No weights provided!\")\n",
    "                W = weights\n",
    "            case \"zero\":\n",
    "                W = 0\n",
    "            case _:\n",
    "                W = nengo.Dense(\n",
    "                    shape,\n",
    "                    init=nengo.dists.Gaussian(0, 0.5),\n",
    "                )\n",
    "        return W\n",
    "\n",
    "    return inner\n",
    "\n",
    "\n",
    "class Delay:\n",
    "    def __init__(self, dimensions, timesteps=50):\n",
    "        self.history = np.zeros((timesteps, dimensions))\n",
    "\n",
    "    def step(self, t, x):\n",
    "        self.history = np.roll(self.history, -1)\n",
    "        self.history[-1] = x\n",
    "        return self.history[0]\n",
    "\n",
    "\n",
    "# Function to inhibit the error population after 15s\n",
    "def inhib(t):\n",
    "    return 2 if t > duration * 0.6 else 0.0\n",
    "\n",
    "\n",
    "stim_shape = (15, 15)\n",
    "stim_size = np.prod(stim_shape)\n",
    "bar_generator = BarGenerator(stim_shape)\n",
    "\n",
    "# Prepare dataset\n",
    "X_train, y_train = bar_generator.generate_bars(\n",
    "    2000,\n",
    "    min_offset=(5, 5),\n",
    "    max_offset=(11, 11),\n",
    "    min_angle=0,\n",
    "    max_angle=180,\n",
    "    min_dim=(2, 10),\n",
    "    max_dim=(3, 20),\n",
    ")\n",
    "y_train = (y_train - 90) / 180\n",
    "\n",
    "\n",
    "# Simulation parameters\n",
    "dt = 1e-3\n",
    "max_rate = 150  # Hz\n",
    "amp = 1.0\n",
    "rate_target = max_rate * amp  # must be in amplitude scaled units\n",
    "\n",
    "n_hidden_neurons = 64\n",
    "n_latent_variables = 3\n",
    "n_state_neurons = 10\n",
    "presentation_time = 0.2\n",
    "duration = 10\n",
    "sample_every = 10 * dt\n",
    "\n",
    "learning_rate = 6e-8\n",
    "delay = Delay(1, timesteps=int(0.1 / dt))\n",
    "\n",
    "\n",
    "default_neuron = nengo.AdaptiveLIF(amplitude=amp, tau_rc=0.01)\n",
    "default_rates = nengo.dists.Choice([max_rate])\n",
    "default_intercepts = nengo.dists.Choice([0])\n",
    "\n",
    "layer_confs = [\n",
    "    dict(\n",
    "        name=\"state_node\",\n",
    "        neuron=None,\n",
    "        output=lambda t: y_train[int(t / presentation_time)],\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"state\",\n",
    "        n_neurons=n_state_neurons,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"delay_node\",\n",
    "        neuron=None,\n",
    "        output=delay.step,\n",
    "        size_in=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"delayed_state\",\n",
    "        n_neurons=10,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"delta_state\",\n",
    "        n_neurons=10,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"stimulus\",\n",
    "        neuron=None,\n",
    "        output=lambda t: X_train[int(t / presentation_time)].ravel(),\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"stim\",\n",
    "        neuron=nengo.PoissonSpiking(nengo.LIFRate(amplitude=amp)),\n",
    "        n_neurons=stim_size,\n",
    "        dimensions=3,\n",
    "        on_chip=False,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"hidden\",\n",
    "        n_neurons=n_hidden_neurons,\n",
    "        dimensions=2,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"output\",\n",
    "        n_neurons=stim_size,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"inhibitor\",\n",
    "        n_neurons=1,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"reconstruction_error\",\n",
    "        n_neurons=stim_size,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "]\n",
    "\n",
    "conn_confs = [\n",
    "    # state variable: angle\n",
    "    dict(\n",
    "        pre=\"state_node\",\n",
    "        post=\"state\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"state_node\",\n",
    "        post=\"delay_node\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"delay_node\",\n",
    "        post=\"delayed_state\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"state\",\n",
    "        post=\"delta_state\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"delayed_state\",\n",
    "        post=\"delta_state\",\n",
    "        transform=gen_transform(\"identity_inhibition\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"stimulus\",\n",
    "        post=\"stim_neurons\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"stim_neurons\",\n",
    "        post=\"hidden_neurons\",\n",
    "        #learning_rule=nengo.Oja(learning_rate=learning_rate),\n",
    "        synapse=0.01,\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"hidden_neurons\",\n",
    "        post=\"inhibitor_neurons\",\n",
    "        synapse=0.01,\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"inhibitor_neurons\",\n",
    "        post=\"hidden_neurons\",\n",
    "        transform=gen_transform(\"custom\", weights=-4 * np.ones((n_hidden_neurons, 1))),\n",
    "        synapse=0.01,\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"hidden_neurons\",\n",
    "        post=\"output_neurons\",\n",
    "        transform=gen_transform(),\n",
    "        synapse=0.01,\n",
    "        #learning_rule=nengo.PES(learning_rate=1e-7),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"stim_neurons\",\n",
    "        post=\"reconstruction_error_neurons\",\n",
    "        transform=gen_transform(\"identity_inhibition\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"output_neurons\",\n",
    "        post=\"reconstruction_error_neurons\",\n",
    "    ),\n",
    "]\n",
    "\n",
    "learning_confs = []\n",
    "\n",
    "\n",
    "# Create the Nengo model\n",
    "with nengo.Network(label=\"tacnet\", seed=1) as model:\n",
    "    layers = dict()\n",
    "    connections = dict()\n",
    "    probes = dict()\n",
    "\n",
    "    # Create layers\n",
    "    for k, layer_conf in enumerate(layer_confs):\n",
    "        layer_conf = dict(layer_conf)  # Copy layer configuration\n",
    "        name = layer_conf.pop(\"name\")\n",
    "        n_neurons = layer_conf.pop(\"n_neurons\", 1)\n",
    "        dimensions = layer_conf.pop(\"dimensions\", 1)\n",
    "        encoders = layer_conf.pop(\n",
    "            \"encoders\", nengo.dists.ScatteredHypersphere(surface=True)\n",
    "        )\n",
    "        max_rates = layer_conf.pop(\"max_rates\", default_rates)\n",
    "        radius = layer_conf.pop(\"radius\", 1.0)\n",
    "        neuron_type = layer_conf.pop(\"neuron\", default_neuron)\n",
    "        on_chip = layer_conf.pop(\"on_chip\", False)\n",
    "        block = layer_conf.pop(\"block\", None)\n",
    "        output = layer_conf.pop(\"output\", None)\n",
    "        size_in = layer_conf.pop(\"size_in\", None)\n",
    "\n",
    "        assert len(layer_conf) == 0, \"Unused fields in {}: {}\".format(\n",
    "            [name], list(layer_conf)\n",
    "        )\n",
    "\n",
    "        if neuron_type is None:\n",
    "            assert not on_chip, \"Nodes can only be run off-chip\"\n",
    "\n",
    "            layer = nengo.Node(output=output, size_in=size_in, label=name)\n",
    "            layers[name] = layer\n",
    "            probe = nengo.Probe(\n",
    "                layer, synapse=0.01, sample_every=sample_every, label=\"%s_probe\" % name\n",
    "            )\n",
    "            probes[name] = probe\n",
    "        else:\n",
    "            layer = nengo.Ensemble(\n",
    "                n_neurons,\n",
    "                dimensions=dimensions,\n",
    "                radius=radius,\n",
    "                encoders=encoders,\n",
    "                intercepts=default_intercepts,\n",
    "                neuron_type=neuron_type,\n",
    "                max_rates=max_rates,\n",
    "                normalize_encoders=True,\n",
    "                label=name,\n",
    "            )\n",
    "            layers[name] = layer\n",
    "            layers[name + \"_neurons\"] = layer.neurons\n",
    "\n",
    "            # Add a probe so we can measure individual layer rates\n",
    "            probe = nengo.Probe(\n",
    "                layer, synapse=0.01, sample_every=sample_every, label=\"%s_probe\" % name\n",
    "            )\n",
    "            probes[name] = probe\n",
    "            probe = nengo.Probe(\n",
    "                layer.neurons,\n",
    "                synapse=0.01,\n",
    "                sample_every=sample_every,\n",
    "                label=\"%s_neurons_probe\" % name,\n",
    "            )\n",
    "            probes[name + \"_neurons\"] = probe\n",
    "\n",
    "    for k, conn_conf in enumerate(conn_confs):\n",
    "        conn_conf = dict(conn_conf)  # Copy connection configuration\n",
    "        pre = conn_conf.pop(\"pre\")\n",
    "        post = conn_conf.pop(\"post\")\n",
    "        synapse = conn_conf.pop(\"synapse\", None)\n",
    "        solver = conn_conf.pop(\"solver\", None)\n",
    "        transform = conn_conf.pop(\"transform\", gen_transform())\n",
    "        learning_rule = conn_conf.pop(\"learning_rule\", None)\n",
    "        name = \"{}2{}\".format(pre, post)\n",
    "        function = conn_conf.pop(\"function\", None)\n",
    "\n",
    "        assert len(conn_conf) == 0, \"Unused fields in {}: {}\".format(\n",
    "            [name], list(layer_conf)\n",
    "        )\n",
    "        conn = nengo.Connection(\n",
    "            layers[pre],\n",
    "            layers[post],\n",
    "            function=function,\n",
    "            transform=transform((layers[post].size_in, layers[pre].size_in)),\n",
    "            synapse=synapse,\n",
    "            label=name,\n",
    "        )\n",
    "        if solver:\n",
    "            conn.solver = solver\n",
    "        if learning_rule:\n",
    "            conn.learning_rule_type = learning_rule\n",
    "        connections[name] = conn\n",
    "\n",
    "        probe = nengo.Probe(\n",
    "            conn,\n",
    "            \"weights\",\n",
    "            synapse=0.01,\n",
    "            sample_every=sample_every,\n",
    "            label=\"weights_{}\".format(name),\n",
    "        )\n",
    "        probes[name] = probe\n",
    "\n",
    "    # Connect learning rule\n",
    "    for k, learning_conf in enumerate(learning_confs):\n",
    "        learning_conf = dict(learning_conf)\n",
    "        pre = learning_conf.pop(\"pre\")\n",
    "        post = learning_conf.pop(\"post\")\n",
    "        transform = learning_conf.pop(\"transform\", 1)\n",
    "        nengo.Connection(\n",
    "            layers[pre],\n",
    "            connections[post].learning_rule,\n",
    "            transform=transform,\n",
    "        )\n",
    "\n",
    "\"\"\"Run in non-GUI mode\n",
    "\"\"\"\n",
    "with nengo.Simulator(model, dt=dt, optimize=True) as sim:\n",
    "    sim.run(duration)\n",
    "\n",
    "conn_name = \"{}2{}\".format(\"stim_neurons\", \"hidden_neurons\")\n",
    "ens_names = [\"state\", \"stim_neurons\", \"hidden_neurons\", \"hidden\"]\n",
    "\n",
    "plt.figure(figsize=(5, 10))\n",
    "# Find weight row with max variance\n",
    "neuron = np.argmax(np.mean(np.var(sim.data[probes[conn_name]], axis=0), axis=1))\n",
    "plt.plot(sim.trange(sample_every), sim.data[probes[conn_name]][:, neuron, :])\n",
    "plt.xlabel(\"time (s)\")\n",
    "plt.ylabel(\"weights\")\n",
    "\n",
    "fig, axs = plt.subplots(len(ens_names), 1, figsize=(5 * len(ens_names), 10))\n",
    "for i, ens_name in enumerate(ens_names):\n",
    "    if \"neurons\" in ens_name:\n",
    "        plot_spikes(\n",
    "            sim.trange(sample_every=sample_every), sim.data[probes[ens_name]], ax=axs[i]\n",
    "        )\n",
    "        axs[i].set_ylabel(\"neuron\")\n",
    "    else:\n",
    "        axs[i].plot(sim.trange(sample_every=sample_every), sim.data[probes[ens_name]])\n",
    "        axs[i].set_ylabel(\"encoder\")\n",
    "    axs[i].set_title(ens_name)\n",
    "    axs[i].set_xlabel(\"time (s)\")\n",
    "    axs[i].grid()\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "c1670a37",
   "metadata": {},
   "outputs": [],
   "source": [
    "sim.data[probes[\"hidden_neurons\"]]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "9c8c35d3",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Copyright 2023 wngfra.\n",
    "# SPDX-License-Identifier: Apache-2.0\n",
    "\n",
    "import os\n",
    "from typing import Optional\n",
    "\n",
    "import nengo\n",
    "import numpy as np\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "from BarGenerator import BarGenerator\n",
    "from custom_learning_rules import SynapticSampling\n",
    "from nengo_extras.plot_spikes import plot_spikes\n",
    "\n",
    "font = {\"weight\": \"normal\", \"size\": 30}\n",
    "\n",
    "matplotlib.rc(\"font\", **font)\n",
    "\n",
    "\n",
    "def gen_transform(pattern=\"random\", weights=None):\n",
    "    W: Optional[np.ndarray] = None\n",
    "\n",
    "    def inner(shape, weights=weights):\n",
    "        \"\"\"_summary_\n",
    "\n",
    "        Args:\n",
    "            shape (array_like): Linear transform mapping of shape (size_out, size_mid).\n",
    "        Returns:\n",
    "            _type_: _description_\n",
    "        \"\"\"\n",
    "        match pattern:\n",
    "            case \"identity_excitation\":\n",
    "                W = 1\n",
    "            case \"identity_inhibition\":\n",
    "                W = -1\n",
    "            case \"exclusive_excitation\":\n",
    "                assert shape[0] == shape[1], \"Transform matrix is not symmetric!\"\n",
    "                W = np.ones(shape) - np.eye(shape[0])\n",
    "            case \"exclusive_inhibition\":\n",
    "                assert shape[0] == shape[1], \"Transform matrix is not symmetric!\"\n",
    "                W = -np.ones(shape) + 2 * np.eye(shape[0])\n",
    "                W[W < 0] *= 2\n",
    "            case \"custom\":\n",
    "                if weights is None:\n",
    "                    raise ValueError(\"No weights provided!\")\n",
    "                W = weights\n",
    "            case \"zero\":\n",
    "                W = 0\n",
    "            case _:\n",
    "                W = nengo.Dense(\n",
    "                    shape,\n",
    "                    init=nengo.dists.Gaussian(0, 0.5),\n",
    "                )\n",
    "        return W\n",
    "\n",
    "    return inner\n",
    "\n",
    "\n",
    "class Delay:\n",
    "    def __init__(self, dimensions, timesteps=50):\n",
    "        self.history = np.zeros((timesteps, dimensions))\n",
    "\n",
    "    def step(self, t, x):\n",
    "        self.history = np.roll(self.history, -1)\n",
    "        self.history[-1] = x\n",
    "        return self.history[0]\n",
    "\n",
    "\n",
    "# Function to inhibit the error population after 15s\n",
    "def inhib(t):\n",
    "    return 2 if t > duration * 0.6 else 0.0\n",
    "\n",
    "\n",
    "stim_shape = (15, 15)\n",
    "stim_size = np.prod(stim_shape)\n",
    "bar_generator = BarGenerator(stim_shape)\n",
    "\n",
    "# Prepare dataset\n",
    "X_train, y_train = bar_generator.generate_bars(\n",
    "    2000,\n",
    "    min_offset=(5, 5),\n",
    "    max_offset=(11, 11),\n",
    "    min_angle=0,\n",
    "    max_angle=180,\n",
    "    min_dim=(2, 10),\n",
    "    max_dim=(3, 20),\n",
    ")\n",
    "y_train = (y_train - 90) / 180\n",
    "\n",
    "\n",
    "# Simulation parameters\n",
    "dt = 1e-3\n",
    "max_rate = 150  # Hz\n",
    "amp = 1.0\n",
    "rate_target = max_rate * amp  # must be in amplitude scaled units\n",
    "\n",
    "n_hidden_neurons = 64\n",
    "n_latent_variables = 3\n",
    "n_state_neurons = 10\n",
    "presentation_time = 10\n",
    "duration = 10\n",
    "sample_every = 10 * dt\n",
    "\n",
    "learning_rate = 6e-8\n",
    "delay = Delay(1, timesteps=int(0.1 / dt))\n",
    "\n",
    "\n",
    "default_neuron = nengo.AdaptiveLIF(amplitude=amp, tau_rc=0.01)\n",
    "default_rates = nengo.dists.Choice([max_rate])\n",
    "default_intercepts = nengo.dists.Choice([0])\n",
    "\n",
    "layer_confs = [\n",
    "    dict(\n",
    "        name=\"state_node\",\n",
    "        neuron=None,\n",
    "        output=lambda t: y_train[int(t / presentation_time)],\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"state\",\n",
    "        n_neurons=n_state_neurons,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"delay_node\",\n",
    "        neuron=None,\n",
    "        output=delay.step,\n",
    "        size_in=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"delayed_state\",\n",
    "        n_neurons=10,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"delta_state\",\n",
    "        n_neurons=10,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"stimulus\",\n",
    "        neuron=None,\n",
    "        output=lambda t: X_train[int(t / presentation_time)].ravel(),\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"stim\",\n",
    "        neuron=nengo.PoissonSpiking(nengo.LIFRate(amplitude=amp)),\n",
    "        n_neurons=stim_size,\n",
    "        dimensions=3,\n",
    "        on_chip=False,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"hidden\",\n",
    "        n_neurons=n_hidden_neurons,\n",
    "        dimensions=2,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"output\",\n",
    "        n_neurons=stim_size,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"inhibitor\",\n",
    "        n_neurons=1,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"reconstruction_error\",\n",
    "        n_neurons=stim_size,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "]\n",
    "\n",
    "conn_confs = [\n",
    "    # state variable: angle\n",
    "    dict(\n",
    "        pre=\"state_node\",\n",
    "        post=\"state\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"state_node\",\n",
    "        post=\"delay_node\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"delay_node\",\n",
    "        post=\"delayed_state\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"state\",\n",
    "        post=\"delta_state\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"delayed_state\",\n",
    "        post=\"delta_state\",\n",
    "        transform=gen_transform(\"identity_inhibition\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"stimulus\",\n",
    "        post=\"stim_neurons\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"stim_neurons\",\n",
    "        post=\"hidden_neurons\",\n",
    "        #learning_rule=nengo.Oja(learning_rate=learning_rate),\n",
    "        synapse=0.01,\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"hidden_neurons\",\n",
    "        post=\"inhibitor_neurons\",\n",
    "        synapse=0.01,\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"inhibitor_neurons\",\n",
    "        post=\"hidden_neurons\",\n",
    "        transform=gen_transform(\"custom\", weights=-4 * np.ones((n_hidden_neurons, 1))),\n",
    "        synapse=0.01,\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"hidden_neurons\",\n",
    "        post=\"output_neurons\",\n",
    "        transform=gen_transform(),\n",
    "        synapse=0.01,\n",
    "        #learning_rule=nengo.PES(learning_rate=1e-7),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"stim_neurons\",\n",
    "        post=\"reconstruction_error_neurons\",\n",
    "        transform=gen_transform(\"identity_inhibition\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"output_neurons\",\n",
    "        post=\"reconstruction_error_neurons\",\n",
    "    ),\n",
    "]\n",
    "\n",
    "learning_confs = []\n",
    "\n",
    "\n",
    "# Create the Nengo model\n",
    "with nengo.Network(label=\"tacnet\", seed=1) as model:\n",
    "    layers = dict()\n",
    "    connections = dict()\n",
    "    probes = dict()\n",
    "\n",
    "    # Create layers\n",
    "    for k, layer_conf in enumerate(layer_confs):\n",
    "        layer_conf = dict(layer_conf)  # Copy layer configuration\n",
    "        name = layer_conf.pop(\"name\")\n",
    "        n_neurons = layer_conf.pop(\"n_neurons\", 1)\n",
    "        dimensions = layer_conf.pop(\"dimensions\", 1)\n",
    "        encoders = layer_conf.pop(\n",
    "            \"encoders\", nengo.dists.ScatteredHypersphere(surface=True)\n",
    "        )\n",
    "        max_rates = layer_conf.pop(\"max_rates\", default_rates)\n",
    "        radius = layer_conf.pop(\"radius\", 1.0)\n",
    "        neuron_type = layer_conf.pop(\"neuron\", default_neuron)\n",
    "        on_chip = layer_conf.pop(\"on_chip\", False)\n",
    "        block = layer_conf.pop(\"block\", None)\n",
    "        output = layer_conf.pop(\"output\", None)\n",
    "        size_in = layer_conf.pop(\"size_in\", None)\n",
    "\n",
    "        assert len(layer_conf) == 0, \"Unused fields in {}: {}\".format(\n",
    "            [name], list(layer_conf)\n",
    "        )\n",
    "\n",
    "        if neuron_type is None:\n",
    "            assert not on_chip, \"Nodes can only be run off-chip\"\n",
    "\n",
    "            layer = nengo.Node(output=output, size_in=size_in, label=name)\n",
    "            layers[name] = layer\n",
    "            probe = nengo.Probe(\n",
    "                layer, synapse=0.01, sample_every=sample_every, label=\"%s_probe\" % name\n",
    "            )\n",
    "            probes[name] = probe\n",
    "        else:\n",
    "            layer = nengo.Ensemble(\n",
    "                n_neurons,\n",
    "                dimensions=dimensions,\n",
    "                radius=radius,\n",
    "                encoders=encoders,\n",
    "                intercepts=default_intercepts,\n",
    "                neuron_type=neuron_type,\n",
    "                max_rates=max_rates,\n",
    "                normalize_encoders=True,\n",
    "                label=name,\n",
    "            )\n",
    "            layers[name] = layer\n",
    "            layers[name + \"_neurons\"] = layer.neurons\n",
    "\n",
    "            # Add a probe so we can measure individual layer rates\n",
    "            probe = nengo.Probe(\n",
    "                layer, synapse=0.01, sample_every=sample_every, label=\"%s_probe\" % name\n",
    "            )\n",
    "            probes[name] = probe\n",
    "            probe = nengo.Probe(\n",
    "                layer.neurons,\n",
    "                synapse=0.01,\n",
    "                sample_every=sample_every,\n",
    "                label=\"%s_neurons_probe\" % name,\n",
    "            )\n",
    "            probes[name + \"_neurons\"] = probe\n",
    "\n",
    "    for k, conn_conf in enumerate(conn_confs):\n",
    "        conn_conf = dict(conn_conf)  # Copy connection configuration\n",
    "        pre = conn_conf.pop(\"pre\")\n",
    "        post = conn_conf.pop(\"post\")\n",
    "        synapse = conn_conf.pop(\"synapse\", None)\n",
    "        solver = conn_conf.pop(\"solver\", None)\n",
    "        transform = conn_conf.pop(\"transform\", gen_transform())\n",
    "        learning_rule = conn_conf.pop(\"learning_rule\", None)\n",
    "        name = \"{}2{}\".format(pre, post)\n",
    "        function = conn_conf.pop(\"function\", None)\n",
    "\n",
    "        assert len(conn_conf) == 0, \"Unused fields in {}: {}\".format(\n",
    "            [name], list(layer_conf)\n",
    "        )\n",
    "        conn = nengo.Connection(\n",
    "            layers[pre],\n",
    "            layers[post],\n",
    "            function=function,\n",
    "            transform=transform((layers[post].size_in, layers[pre].size_in)),\n",
    "            synapse=synapse,\n",
    "            label=name,\n",
    "        )\n",
    "        if solver:\n",
    "            conn.solver = solver\n",
    "        if learning_rule:\n",
    "            conn.learning_rule_type = learning_rule\n",
    "        connections[name] = conn\n",
    "\n",
    "        probe = nengo.Probe(\n",
    "            conn,\n",
    "            \"weights\",\n",
    "            synapse=0.01,\n",
    "            sample_every=sample_every,\n",
    "            label=\"weights_{}\".format(name),\n",
    "        )\n",
    "        probes[name] = probe\n",
    "\n",
    "    # Connect learning rule\n",
    "    for k, learning_conf in enumerate(learning_confs):\n",
    "        learning_conf = dict(learning_conf)\n",
    "        pre = learning_conf.pop(\"pre\")\n",
    "        post = learning_conf.pop(\"post\")\n",
    "        transform = learning_conf.pop(\"transform\", 1)\n",
    "        nengo.Connection(\n",
    "            layers[pre],\n",
    "            connections[post].learning_rule,\n",
    "            transform=transform,\n",
    "        )\n",
    "\n",
    "\"\"\"Run in non-GUI mode\n",
    "\"\"\"\n",
    "with nengo.Simulator(model, dt=dt, optimize=True) as sim:\n",
    "    sim.run(duration)\n",
    "\n",
    "conn_name = \"{}2{}\".format(\"stim_neurons\", \"hidden_neurons\")\n",
    "ens_names = [\"state\", \"stim_neurons\", \"hidden_neurons\", \"hidden\"]\n",
    "\n",
    "plt.figure(figsize=(5, 10))\n",
    "# Find weight row with max variance\n",
    "neuron = np.argmax(np.mean(np.var(sim.data[probes[conn_name]], axis=0), axis=1))\n",
    "plt.plot(sim.trange(sample_every), sim.data[probes[conn_name]][:, neuron, :])\n",
    "plt.xlabel(\"time (s)\")\n",
    "plt.ylabel(\"weights\")\n",
    "\n",
    "fig, axs = plt.subplots(len(ens_names), 1, figsize=(5 * len(ens_names), 10))\n",
    "for i, ens_name in enumerate(ens_names):\n",
    "    if \"neurons\" in ens_name:\n",
    "        plot_spikes(\n",
    "            sim.trange(sample_every=sample_every), sim.data[probes[ens_name]], ax=axs[i]\n",
    "        )\n",
    "        axs[i].set_ylabel(\"neuron\")\n",
    "    else:\n",
    "        axs[i].plot(sim.trange(sample_every=sample_every), sim.data[probes[ens_name]])\n",
    "        axs[i].set_ylabel(\"encoder\")\n",
    "    axs[i].set_title(ens_name)\n",
    "    axs[i].set_xlabel(\"time (s)\")\n",
    "    axs[i].grid()\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "08789073",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Copyright 2023 wngfra.\n",
    "# SPDX-License-Identifier: Apache-2.0\n",
    "\n",
    "import os\n",
    "from typing import Optional\n",
    "\n",
    "import nengo\n",
    "import numpy as np\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "from BarGenerator import BarGenerator\n",
    "from custom_learning_rules import SynapticSampling\n",
    "from nengo_extras.plot_spikes import plot_spikes\n",
    "\n",
    "font = {\"weight\": \"normal\", \"size\": 30}\n",
    "\n",
    "matplotlib.rc(\"font\", **font)\n",
    "\n",
    "\n",
    "def gen_transform(pattern=\"random\", weights=None):\n",
    "    W: Optional[np.ndarray] = None\n",
    "\n",
    "    def inner(shape, weights=weights):\n",
    "        \"\"\"_summary_\n",
    "\n",
    "        Args:\n",
    "            shape (array_like): Linear transform mapping of shape (size_out, size_mid).\n",
    "        Returns:\n",
    "            _type_: _description_\n",
    "        \"\"\"\n",
    "        match pattern:\n",
    "            case \"identity_excitation\":\n",
    "                W = 1\n",
    "            case \"identity_inhibition\":\n",
    "                W = -1\n",
    "            case \"exclusive_excitation\":\n",
    "                assert shape[0] == shape[1], \"Transform matrix is not symmetric!\"\n",
    "                W = np.ones(shape) - np.eye(shape[0])\n",
    "            case \"exclusive_inhibition\":\n",
    "                assert shape[0] == shape[1], \"Transform matrix is not symmetric!\"\n",
    "                W = -np.ones(shape) + 2 * np.eye(shape[0])\n",
    "                W[W < 0] *= 2\n",
    "            case \"custom\":\n",
    "                if weights is None:\n",
    "                    raise ValueError(\"No weights provided!\")\n",
    "                W = weights\n",
    "            case \"zero\":\n",
    "                W = 0\n",
    "            case _:\n",
    "                W = nengo.Dense(\n",
    "                    shape,\n",
    "                    init=nengo.dists.Gaussian(0, 0.5),\n",
    "                )\n",
    "        return W\n",
    "\n",
    "    return inner\n",
    "\n",
    "\n",
    "class Delay:\n",
    "    def __init__(self, dimensions, timesteps=50):\n",
    "        self.history = np.zeros((timesteps, dimensions))\n",
    "\n",
    "    def step(self, t, x):\n",
    "        self.history = np.roll(self.history, -1)\n",
    "        self.history[-1] = x\n",
    "        return self.history[0]\n",
    "\n",
    "\n",
    "# Function to inhibit the error population after 15s\n",
    "def inhib(t):\n",
    "    return 2 if t > duration * 0.6 else 0.0\n",
    "\n",
    "\n",
    "stim_shape = (15, 15)\n",
    "stim_size = np.prod(stim_shape)\n",
    "bar_generator = BarGenerator(stim_shape)\n",
    "\n",
    "# Prepare dataset\n",
    "X_train, y_train = bar_generator.generate_bars(\n",
    "    2000,\n",
    "    min_offset=(5, 5),\n",
    "    max_offset=(11, 11),\n",
    "    min_angle=0,\n",
    "    max_angle=180,\n",
    "    min_dim=(2, 10),\n",
    "    max_dim=(3, 20),\n",
    ")\n",
    "y_train = (y_train - 90) / 180\n",
    "\n",
    "\n",
    "# Simulation parameters\n",
    "dt = 1e-3\n",
    "max_rate = 150  # Hz\n",
    "amp = 1.0\n",
    "rate_target = max_rate * amp  # must be in amplitude scaled units\n",
    "\n",
    "n_hidden_neurons = 64\n",
    "n_latent_variables = 3\n",
    "n_state_neurons = 10\n",
    "presentation_time = 10\n",
    "duration = 10\n",
    "sample_every = 1 * dt\n",
    "\n",
    "learning_rate = 6e-8\n",
    "delay = Delay(1, timesteps=int(0.1 / dt))\n",
    "\n",
    "\n",
    "default_neuron = nengo.AdaptiveLIF(amplitude=amp, tau_rc=0.01)\n",
    "default_rates = nengo.dists.Choice([max_rate])\n",
    "default_intercepts = nengo.dists.Choice([0])\n",
    "\n",
    "layer_confs = [\n",
    "    dict(\n",
    "        name=\"state_node\",\n",
    "        neuron=None,\n",
    "        output=lambda t: y_train[int(t / presentation_time)],\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"state\",\n",
    "        n_neurons=n_state_neurons,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"delay_node\",\n",
    "        neuron=None,\n",
    "        output=delay.step,\n",
    "        size_in=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"delayed_state\",\n",
    "        n_neurons=10,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"delta_state\",\n",
    "        n_neurons=10,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"stimulus\",\n",
    "        neuron=None,\n",
    "        output=lambda t: X_train[int(t / presentation_time)].ravel(),\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"stim\",\n",
    "        neuron=nengo.PoissonSpiking(nengo.LIFRate(amplitude=amp)),\n",
    "        n_neurons=stim_size,\n",
    "        dimensions=3,\n",
    "        on_chip=False,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"hidden\",\n",
    "        n_neurons=n_hidden_neurons,\n",
    "        dimensions=2,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"output\",\n",
    "        n_neurons=stim_size,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"inhibitor\",\n",
    "        n_neurons=1,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "    dict(\n",
    "        name=\"reconstruction_error\",\n",
    "        n_neurons=stim_size,\n",
    "        dimensions=1,\n",
    "    ),\n",
    "]\n",
    "\n",
    "conn_confs = [\n",
    "    # state variable: angle\n",
    "    dict(\n",
    "        pre=\"state_node\",\n",
    "        post=\"state\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"state_node\",\n",
    "        post=\"delay_node\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"delay_node\",\n",
    "        post=\"delayed_state\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"state\",\n",
    "        post=\"delta_state\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"delayed_state\",\n",
    "        post=\"delta_state\",\n",
    "        transform=gen_transform(\"identity_inhibition\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"stimulus\",\n",
    "        post=\"stim_neurons\",\n",
    "        transform=gen_transform(\"identity_excitation\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"stim_neurons\",\n",
    "        post=\"hidden_neurons\",\n",
    "        #learning_rule=nengo.Oja(learning_rate=learning_rate),\n",
    "        synapse=0.01,\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"hidden_neurons\",\n",
    "        post=\"inhibitor_neurons\",\n",
    "        synapse=0.01,\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"inhibitor_neurons\",\n",
    "        post=\"hidden_neurons\",\n",
    "        transform=gen_transform(\"custom\", weights=-4 * np.ones((n_hidden_neurons, 1))),\n",
    "        synapse=0.01,\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"hidden_neurons\",\n",
    "        post=\"output_neurons\",\n",
    "        transform=gen_transform(),\n",
    "        synapse=0.01,\n",
    "        #learning_rule=nengo.PES(learning_rate=1e-7),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"stim_neurons\",\n",
    "        post=\"reconstruction_error_neurons\",\n",
    "        transform=gen_transform(\"identity_inhibition\"),\n",
    "    ),\n",
    "    dict(\n",
    "        pre=\"output_neurons\",\n",
    "        post=\"reconstruction_error_neurons\",\n",
    "    ),\n",
    "]\n",
    "\n",
    "learning_confs = []\n",
    "\n",
    "\n",
    "# Create the Nengo model\n",
    "with nengo.Network(label=\"tacnet\", seed=1) as model:\n",
    "    layers = dict()\n",
    "    connections = dict()\n",
    "    probes = dict()\n",
    "\n",
    "    # Create layers\n",
    "    for k, layer_conf in enumerate(layer_confs):\n",
    "        layer_conf = dict(layer_conf)  # Copy layer configuration\n",
    "        name = layer_conf.pop(\"name\")\n",
    "        n_neurons = layer_conf.pop(\"n_neurons\", 1)\n",
    "        dimensions = layer_conf.pop(\"dimensions\", 1)\n",
    "        encoders = layer_conf.pop(\n",
    "            \"encoders\", nengo.dists.ScatteredHypersphere(surface=True)\n",
    "        )\n",
    "        max_rates = layer_conf.pop(\"max_rates\", default_rates)\n",
    "        radius = layer_conf.pop(\"radius\", 1.0)\n",
    "        neuron_type = layer_conf.pop(\"neuron\", default_neuron)\n",
    "        on_chip = layer_conf.pop(\"on_chip\", False)\n",
    "        block = layer_conf.pop(\"block\", None)\n",
    "        output = layer_conf.pop(\"output\", None)\n",
    "        size_in = layer_conf.pop(\"size_in\", None)\n",
    "\n",
    "        assert len(layer_conf) == 0, \"Unused fields in {}: {}\".format(\n",
    "            [name], list(layer_conf)\n",
    "        )\n",
    "\n",
    "        if neuron_type is None:\n",
    "            assert not on_chip, \"Nodes can only be run off-chip\"\n",
    "\n",
    "            layer = nengo.Node(output=output, size_in=size_in, label=name)\n",
    "            layers[name] = layer\n",
    "            probe = nengo.Probe(\n",
    "                layer, synapse=0.01, sample_every=sample_every, label=\"%s_probe\" % name\n",
    "            )\n",
    "            probes[name] = probe\n",
    "        else:\n",
    "            layer = nengo.Ensemble(\n",
    "                n_neurons,\n",
    "                dimensions=dimensions,\n",
    "                radius=radius,\n",
    "                encoders=encoders,\n",
    "                intercepts=default_intercepts,\n",
    "                neuron_type=neuron_type,\n",
    "                max_rates=max_rates,\n",
    "                normalize_encoders=True,\n",
    "                label=name,\n",
    "            )\n",
    "            layers[name] = layer\n",
    "            layers[name + \"_neurons\"] = layer.neurons\n",
    "\n",
    "            # Add a probe so we can measure individual layer rates\n",
    "            probe = nengo.Probe(\n",
    "                layer, synapse=0.01, sample_every=sample_every, label=\"%s_probe\" % name\n",
    "            )\n",
    "            probes[name] = probe\n",
    "            probe = nengo.Probe(\n",
    "                layer.neurons,\n",
    "                synapse=0.01,\n",
    "                sample_every=sample_every,\n",
    "                label=\"%s_neurons_probe\" % name,\n",
    "            )\n",
    "            probes[name + \"_neurons\"] = probe\n",
    "\n",
    "    for k, conn_conf in enumerate(conn_confs):\n",
    "        conn_conf = dict(conn_conf)  # Copy connection configuration\n",
    "        pre = conn_conf.pop(\"pre\")\n",
    "        post = conn_conf.pop(\"post\")\n",
    "        synapse = conn_conf.pop(\"synapse\", None)\n",
    "        solver = conn_conf.pop(\"solver\", None)\n",
    "        transform = conn_conf.pop(\"transform\", gen_transform())\n",
    "        learning_rule = conn_conf.pop(\"learning_rule\", None)\n",
    "        name = \"{}2{}\".format(pre, post)\n",
    "        function = conn_conf.pop(\"function\", None)\n",
    "\n",
    "        assert len(conn_conf) == 0, \"Unused fields in {}: {}\".format(\n",
    "            [name], list(layer_conf)\n",
    "        )\n",
    "        conn = nengo.Connection(\n",
    "            layers[pre],\n",
    "            layers[post],\n",
    "            function=function,\n",
    "            transform=transform((layers[post].size_in, layers[pre].size_in)),\n",
    "            synapse=synapse,\n",
    "            label=name,\n",
    "        )\n",
    "        if solver:\n",
    "            conn.solver = solver\n",
    "        if learning_rule:\n",
    "            conn.learning_rule_type = learning_rule\n",
    "        connections[name] = conn\n",
    "\n",
    "        probe = nengo.Probe(\n",
    "            conn,\n",
    "            \"weights\",\n",
    "            synapse=0.01,\n",
    "            sample_every=sample_every,\n",
    "            label=\"weights_{}\".format(name),\n",
    "        )\n",
    "        probes[name] = probe\n",
    "\n",
    "    # Connect learning rule\n",
    "    for k, learning_conf in enumerate(learning_confs):\n",
    "        learning_conf = dict(learning_conf)\n",
    "        pre = learning_conf.pop(\"pre\")\n",
    "        post = learning_conf.pop(\"post\")\n",
    "        transform = learning_conf.pop(\"transform\", 1)\n",
    "        nengo.Connection(\n",
    "            layers[pre],\n",
    "            connections[post].learning_rule,\n",
    "            transform=transform,\n",
    "        )\n",
    "\n",
    "\"\"\"Run in non-GUI mode\n",
    "\"\"\"\n",
    "with nengo.Simulator(model, dt=dt, optimize=True) as sim:\n",
    "    sim.run(duration)\n",
    "\n",
    "conn_name = \"{}2{}\".format(\"stim_neurons\", \"hidden_neurons\")\n",
    "ens_names = [\"state\", \"stim_neurons\", \"hidden_neurons\", \"hidden\"]\n",
    "\n",
    "plt.figure(figsize=(5, 10))\n",
    "# Find weight row with max variance\n",
    "neuron = np.argmax(np.mean(np.var(sim.data[probes[conn_name]], axis=0), axis=1))\n",
    "plt.plot(sim.trange(sample_every), sim.data[probes[conn_name]][:, neuron, :])\n",
    "plt.xlabel(\"time (s)\")\n",
    "plt.ylabel(\"weights\")\n",
    "\n",
    "fig, axs = plt.subplots(len(ens_names), 1, figsize=(5 * len(ens_names), 10))\n",
    "for i, ens_name in enumerate(ens_names):\n",
    "    if \"neurons\" in ens_name:\n",
    "        plot_spikes(\n",
    "            sim.trange(sample_every=sample_every), sim.data[probes[ens_name]], ax=axs[i]\n",
    "        )\n",
    "        axs[i].set_ylabel(\"neuron\")\n",
    "    else:\n",
    "        axs[i].plot(sim.trange(sample_every=sample_every), sim.data[probes[ens_name]])\n",
    "        axs[i].set_ylabel(\"encoder\")\n",
    "    axs[i].set_title(ens_name)\n",
    "    axs[i].set_xlabel(\"time (s)\")\n",
    "    axs[i].grid()\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "cc212268",
   "metadata": {},
   "outputs": [],
   "source": [
    "sim.data[probes[\"hidden_neurons\"]].shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "0f3af9e7",
   "metadata": {},
   "outputs": [],
   "source": [
    "sim.data[probes[\"hidden_neurons\"]].shape\n",
    "data = np.mean(arr.reshape(-1, 100, 64), axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "4bc233ff",
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_data = sim.data[probes[\"hidden_neurons\"]]\n",
    "data = np.mean(arr.reshape(-1, 100, 64), axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "c88ed72e",
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_data = sim.data[probes[\"hidden_neurons\"]]\n",
    "data = np.mean(raw_data.reshape(-1, 100, 64), axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "ead0b860",
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_data = sim.data[probes[\"hidden_neurons\"]]\n",
    "data = np.mean(raw_data.reshape(-1, 100, 64), axis=1)\n",
    "data.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "829b3a24",
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_data = sim.data[probes[\"hidden_neurons\"]].reshape(-1, 100, 64)\n",
    "data = np.mean(raw_data.reshape(-1, 100, 64), axis=1)\n",
    "data.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "a420fac2",
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_data = sim.data[probes[\"hidden_neurons\"]].reshape(-1, 100, 64)\n",
    "data.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "23ee89a9",
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_data = sim.data[probes[\"hidden_neurons\"]].reshape(100, 100, 64)\n",
    "data.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "cbb48516",
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_data = sim.data[probes[\"hidden_neurons\"]].reshape(100, 100, 64)\n",
    "raw_data.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "b98a48f6",
   "metadata": {},
   "outputs": [],
   "source": [
    "data = sim.data[probes[\"hidden_neurons\"]].reshape(-1, 100, 64)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "3e59b3ab",
   "metadata": {},
   "outputs": [],
   "source": [
    "data = sim.data[probes[\"hidden_neurons\"]].reshape(-1, 100, 64)\n",
    "data.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "58fab4b8",
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_data = sim.data[probes[\"hidden_neurons\"]].reshape(-1, 100, 64)\n",
    "data = np.mean(raw_data, axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "2cf02707",
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_data = sim.data[probes[\"hidden_neurons\"]].reshape(-1, 100, 64)\n",
    "data = np.mean(raw_data, axis=1)\n",
    "data.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "b8b09e8b",
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_data = sim.data[probes[\"hidden_neurons\"]].reshape(-1, 100, 64)\n",
    "data = np.mean(raw_data, axis=1)\n",
    "plt.imshow(data)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "c4b21a30",
   "metadata": {},
   "outputs": [],
   "source": [
    "raw_data = sim.data[probes[\"hidden_neurons\"]].reshape(-1, 200, 64)\n",
    "data = np.mean(raw_data, axis=1)\n",
    "plt.imshow(data)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "7543dd3e",
   "metadata": {},
   "outputs": [],
   "source": [
    "from matplotlib import cm\n",
    "\n",
    "n_samples = 200\n",
    "raw_data = sim.data[probes[\"hidden_neurons\"]].reshape(-1, n_samples, n_hidden_neurons)\n",
    "data = np.mean(raw_data, axis=1)\n",
    "x = np.linspace(0, n_hidden_neurons, 1)\n",
    "y = np.linspace(0, data.shape[0], 1)\n",
    "X, Y = np.meshgrid(x, y)\n",
    "\n",
    "plt.close(\"all\")\n",
    "fig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n",
    "surf = ax.plot_surface(X, Y, data, cmap=cm.coolwarm,\n",
    "                       linewidth=0, antialiased=False)\n",
    "fig.colorbar(surf, shrink=0.5, aspect=5)\n",
    "\n",
    "plt.figure()\n",
    "plt.imshow(data)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "89d7df13",
   "metadata": {},
   "outputs": [],
   "source": [
    "X.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "77c930a5",
   "metadata": {},
   "outputs": [],
   "source": [
    "from matplotlib import cm\n",
    "\n",
    "n_samples = 200\n",
    "raw_data = sim.data[probes[\"hidden_neurons\"]].reshape(-1, n_samples, n_hidden_neurons)\n",
    "data = np.mean(raw_data, axis=1)\n",
    "x = np.arange(0, 1, n_hidden_neurons)\n",
    "y = np.linspace(0, 1, data.shape[0])\n",
    "X, Y = np.meshgrid(x, y)\n",
    "\n",
    "plt.close(\"all\")\n",
    "fig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n",
    "surf = ax.plot_surface(X, Y, data, cmap=cm.coolwarm,\n",
    "                       linewidth=0, antialiased=False)\n",
    "fig.colorbar(surf, shrink=0.5, aspect=5)\n",
    "\n",
    "plt.figure()\n",
    "plt.imshow(data)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "36886881",
   "metadata": {},
   "outputs": [],
   "source": [
    "from matplotlib import cm\n",
    "%notebook widget\n",
    "\n",
    "n_samples = 200\n",
    "raw_data = sim.data[probes[\"hidden_neurons\"]].reshape(-1, n_samples, n_hidden_neurons)\n",
    "data = np.mean(raw_data, axis=1)\n",
    "x = np.arange(0, 1, n_hidden_neurons)\n",
    "y = np.linspace(0, 1, data.shape[0])\n",
    "X, Y = np.meshgrid(x, y)\n",
    "\n",
    "plt.close(\"all\")\n",
    "fig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n",
    "surf = ax.plot_surface(X, Y, data, cmap=cm.coolwarm,\n",
    "                       linewidth=0, antialiased=False)\n",
    "fig.colorbar(surf, shrink=0.5, aspect=5)\n",
    "\n",
    "plt.figure()\n",
    "plt.imshow(data)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "0e737241",
   "metadata": {},
   "outputs": [],
   "source": [
    "X"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "75eff2ac",
   "metadata": {},
   "outputs": [],
   "source": [
    "X.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "b3379b36",
   "metadata": {},
   "outputs": [],
   "source": [
    "X.shape\n",
    "Y.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "afde283a",
   "metadata": {},
   "outputs": [],
   "source": [
    "data.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "0ecc0240",
   "metadata": {},
   "outputs": [],
   "source": [
    "x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "035d54b4",
   "metadata": {},
   "outputs": [],
   "source": [
    "n_hidden_neurons"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "86e4252a",
   "metadata": {},
   "outputs": [],
   "source": [
    "from matplotlib import cm\n",
    "%notebook widget\n",
    "\n",
    "n_samples = 200\n",
    "raw_data = sim.data[probes[\"hidden_neurons\"]].reshape(-1, n_samples, n_hidden_neurons)\n",
    "data = np.mean(raw_data, axis=1)\n",
    "x = np.arange(0, 1, n_hidden_neurons)\n",
    "y = np.arange(0, 1, data.shape[0])\n",
    "X, Y = np.meshgrid(x, y)\n",
    "\n",
    "plt.close(\"all\")\n",
    "fig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n",
    "surf = ax.plot_surface(X, Y, data, cmap=cm.coolwarm,\n",
    "                       linewidth=0, antialiased=False)\n",
    "fig.colorbar(surf, shrink=0.5, aspect=5)\n",
    "\n",
    "plt.figure()\n",
    "plt.imshow(data)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "0d14e507",
   "metadata": {},
   "outputs": [],
   "source": [
    "from matplotlib import cm\n",
    "%notebook widget\n",
    "\n",
    "n_samples = 200\n",
    "raw_data = sim.data[probes[\"hidden_neurons\"]].reshape(-1, n_samples, n_hidden_neurons)\n",
    "data = np.mean(raw_data, axis=1)\n",
    "X = np.arange(0, 1, n_hidden_neurons)\n",
    "Y = np.arange(0, 1, data.shape[0])\n",
    "X, Y = np.meshgrid(x, y)\n",
    "\n",
    "plt.close(\"all\")\n",
    "fig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n",
    "surf = ax.plot_surface(X, Y, data, cmap=cm.coolwarm,\n",
    "                       linewidth=0, antialiased=False)\n",
    "fig.colorbar(surf, shrink=0.5, aspect=5)\n",
    "\n",
    "plt.figure()\n",
    "plt.imshow(data)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "ed2aba9f",
   "metadata": {},
   "outputs": [],
   "source": [
    "X"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "8e3298d0",
   "metadata": {},
   "outputs": [],
   "source": [
    "Y"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}
